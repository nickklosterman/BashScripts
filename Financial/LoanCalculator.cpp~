/*
 http://en.cppreference.com/w/cpp/io/c/fprintf

*/


#include <math.h>
#include <cstdio>
#include <string.h>
#include <iostream>

float moneyround(float amt);

class AmortizedLoan
{
public:
  AmortizedLoan();
  AmortizedLoan(  float int_rate_, float loan_amount_, float additionalperiodicpaymenttoprincipal_,   int num_pmnts_, int freq_, float monthly_payment);
  AmortizedLoan(  float int_rate_, float loan_amount_, float additionalperiodicpaymenttoprincipal_,   int num_pmnts_, int freq_);
  float get_periodicmortgagepayment();
  float get_principal();
  float get_loan_amount();
  float get_overpaymenttoprincipal();
  void set_principal(float new_p);
  float calc_paymenttowardsinterest();
  float calc_paymenttowardsprincipal();
  void calc_newprincipal();
  float calc_paymentpercentages();//only return the percentage of one and subtract this for the other. want this so can see how quickly the amount going ot int drops off
  //  float get_principal();
  void AmortizationTable();
  void AmortizationTable2();
  void PrintPeriodicMortgagePayment();
private:
  //  string GetPeriodString()
  void reset_principal();
  void calc_periodicmortgagepayment();//float int_rate, int num_pmnts, float principal, int freq);
  void CalcAmortizationValues();
  float int_rate_pct,principal,loan_amount,additionalperiodicpaymenttoprincipal,periodicmortgagepayment,totalcostofloan,totalinterestonloan;
  int num_pmnts,freq,monthstopayoff;
};

void AmortizedLoan::reset_principal()
{
  principal=loan_amount;
}
float AmortizedLoan::get_overpaymenttoprincipal()
{
  return additionalperiodicpaymenttoprincipal;
}
/*
string AmortizedLoan::GetPeriodString()
{
  switch(freq)
    {
    case 1: return "annually";break;
    case 2: return "semi-annually";break;
    case 4: return "quarterly";break;
    case 6: return "bimonthly";break;
    case 12: return "monthly";break;
    case 24: return "twice a month";break;
    case 26: return "biweekly";break;
    case 52: return "weekly";break;
    default: return "periodic";

    }
}
*/

void AmortizedLoan::PrintPeriodicMortgagePayment()
{
  printf("Your XmonthlyXweeklyXetcXX payment will be %.2f.\n" , periodicmortgagepayment);
}


void AmortizedLoan::AmortizationTable()
{
  printf("month interest principal principalleft\n");
  int month=0;
  while (principal > 0.01) //the floating point must put the result off by just enough that the error accumulates over all the iterations.
    {
      //      printf("%d %2.f\n" , month,principal);
      float paymenttowardsinterest=calc_paymenttowardsinterest();
      //printf("payment twd int %d %f\n" , month,paymenttowardsinterest);
      float paymenttowardsprincipal=calc_paymenttowardsprincipal();
      //printf("payment twd print %d %f\n" , month,paymenttowardsprincipal);
      calc_newprincipal();
      month++;
      printf("%d %0.2f %0.2f %0.2f\n" , month,paymenttowardsinterest,paymenttowardsprincipal,principal);
    }
}

AmortizedLoan::AmortizedLoan(  float int_rate_, float loan_amount_, float additionalperiodicpaymenttoprincipal_,   int num_pmnts_, int freq_, float monthlypayment)
{

  principal =  loan_amount_;
  int_rate_pct =  int_rate_ / 100;
  loan_amount = loan_amount_ ;
  additionalperiodicpaymenttoprincipal = additionalperiodicpaymenttoprincipal_;
  num_pmnts =   num_pmnts_;
  freq = freq_;
  calc_periodicmortgagepayment();//int_rate_pct, num_pmnts, principal,freq);

  //override items if monthlypayment specified
  if (monthlypayment>periodicmortgagepayment && monthlypayment!=0) // <- will the second argument eval to false ever? use > 0.01 instead?
    additionalperiodicpaymenttoprincipal =monthlypayment-periodicmortgagepayment;


}


AmortizedLoan::AmortizedLoan(  float int_rate_, float loan_amount_, float additionalperiodicpaymenttoprincipal_,   int num_pmnts_, int freq_)
{
  principal =  loan_amount_;
  int_rate_pct =  int_rate_ / 100;
  loan_amount = loan_amount_ ;
  additionalperiodicpaymenttoprincipal = additionalperiodicpaymenttoprincipal_;
  num_pmnts =   num_pmnts_;
  freq = freq_;
  calc_periodicmortgagepayment();//int_rate_pct, num_pmnts, principal,freq);

}

AmortizedLoan::AmortizedLoan()
{
  principal = int_rate_pct = loan_amount = additionalperiodicpaymenttoprincipal = periodicmortgagepayment = 0;
  num_pmnts = freq = 0;
}
float AmortizedLoan::get_periodicmortgagepayment()
{
  return periodicmortgagepayment;
}
float AmortizedLoan::get_principal()
{
  return principal;
}
float  AmortizedLoan::get_loan_amount()
{
  return loan_amount;
}

void AmortizedLoan::set_principal(float p)
{
  principal=p;
  loan_amount=p;
}

void AmortizedLoan::calc_periodicmortgagepayment() //float int_rate, int num_pmnts, float principal, int freq)
{
  /* This function will calculate the payment amount of a loan.
     @ Inputs
     - int_rate - The interest rate of the loan
     - num_pmnts - The number of payments required
     - principal - The original amount of the loan (minus down-payment)
     - freq - Frequency of payments (weekly, monthly, quarterly, annually)
     @ Returns
     - pmnt_amt - The amount that each payment will be
  */
 
  float rr = int_rate_pct / freq;
  float x = pow((1.0 + rr), num_pmnts);
  float y = rr / (x - 1.0);
  float pmnt_amt = (rr + y) * principal;
  periodicmortgagepayment=moneyround(pmnt_amt);
}

float moneyround(float amt)
{
  return floor(amt*100 +0.5) / 100;
}
float AmortizedLoan::calc_paymenttowardsinterest()
{
  return moneyround(principal* int_rate_pct / freq );
}

float AmortizedLoan::calc_paymenttowardsprincipal()
{
  float paymenttowardsprincipal=0;
  if ( principal>0) // is this redundant? I think it is.
    {
      if (periodicmortgagepayment+additionalperiodicpaymenttoprincipal < principal)
	{//do I really want to calculate this including the add'l payment? It doesn't make sense not to.
	paymenttowardsprincipal=(periodicmortgagepayment+additionalperiodicpaymenttoprincipal-calc_paymenttowardsinterest());
	}
      else
	{
	std::cout<<"h---------------h";
	paymenttowardsprincipal=(principal-calc_paymenttowardsinterest());
	}
    }
  return moneyround(paymenttowardsprincipal);
}

//calculate the amount of each payment that goes toward principal and interest
float AmortizedLoan::calc_paymentpercentages()
{
  float paymenttowardsprincipal=0;
  if ( principal>0) // is this redundant? I think it is.
    {
      if (periodicmortgagepayment+additionalperiodicpaymenttoprincipal < principal)
	{
	paymenttowardsprincipal=(periodicmortgagepayment+additionalperiodicpaymenttoprincipal-calc_paymenttowardsinterest());
	}
      else
	{
	std::cout<<"h---------------h";
	paymenttowardsprincipal=(principal-calc_paymenttowardsinterest());
	}
    }
  return paymenttowardsprincipal;
}

void AmortizedLoan::calc_newprincipal()
{
  float temp=0;
  if (periodicmortgagepayment+additionalperiodicpaymenttoprincipal < principal)
    {
      temp=principal-calc_paymenttowardsprincipal()-additionalperiodicpaymenttoprincipal;
    }
  else
    {
      std::cout<<"final payment was "<<principal<<"; is this the same as the monthly mort payment?"<<periodicmortgagepayment<<"\n";
      std::cout<<"Shouldn't the final payment be exactly one mortgage payment (or only off by a cent or two?)and not less?\n";
    }
  principal=moneyround(temp); //round off the cents so don't accumulate errors. Am guessing that this is how things are calculated by the banks. They don't carry over beyond the cents position.
  //  principal=temp;
  
}
void AmortizedLoan::CalcAmortizationValues() //float periodicpayment,float int_rate, float principal,int freq, additionalperiodicpaymenttoprincipal)
{
  float  paymenttowardsinterest=calc_paymenttowardsinterest();
  float paymenttowardsprincipal=calc_paymenttowardsprincipal();
  if (periodicmortgagepayment<principal)       //if aren't paying extra then you'll hit 0 principal on your final payment, but if pay extra last payment will be less than what your normal payment would've been.
    {
      calc_newprincipal();
    }
  else //this case covers our last payment where the principal is less than the payment, don't need to make 
    {
      principal=0;
    }
  //  return paymenttowardsinterest,paymenttowardsprincipal,principal

}
 
void AmortizedLoan::AmortizationTable2()//periodicpayment,int_rate,principal,freq,additionalperiodicpaymenttoprincipal):
{
  printf("months_to_pay_off total_interest_paid\n");// principal principalleft")
  int month=0;
  float totalinterest=0;
  while (principal > 0)
    {
      float paymenttowardsinterest=calc_paymenttowardsinterest();
      totalinterest+=paymenttowardsinterest;
      float paymenttowardsprincipal=calc_paymenttowardsprincipal();
      calc_newprincipal();
      month++;
    }
  printf("%d %2.f\n" ,month,totalinterest);
}


    
int main()
{
 
  //setup defaults
  float r=4.5;
  int t=360;
  float la=100000.0;
  float ep=0.0;
  int rt = 12;//"monthly"

  AmortizedLoan al(r,la,ep,t,rt,00);

  al.AmortizationTable();  
  al.PrintPeriodicMortgagePayment();
  /*
  //MonthlyPayment=1.5*payment //making a payment of ~150% of the regular mortgage payment will pay off the mortgage in about 1/2 the time.
    

  import sys,getopt

  try:
  options, remainder = getopt.gnu_getopt(sys.argv[1:], 'i:n:l:e:f:m:', ['--interest_rate=',
  '--number_of_payments=',
  '--loan_amount=',
  '--extra_principal_payment_amount=',
  '--payment_frequency=',
  '--monthly_payment_amount=',
  ])
  except getopt.GetoptError, err:
  // printf help information and exit:
  printf str(err) // will printf something like "option -a not recognized"
  //usage()
  sys.exit(2)

  for opt, arg in options:
  if opt in ('-i', '--interest_rate'):
  r = float(arg)
  elif opt in ('-n', '--number_of_payments'):
  t = int(arg)
  elif opt in ('-l', '--loan_amount'):
  la = float(arg)
  elif opt in ('-e', '--extra_principal_payment_amount'):
  ep = float(arg)
  elif opt in ('-f', '--payment_frequency'):
  rt = arg
  elif opt in ('-m', '--monthly_payment_amount'):
  MonthlyPayment = float(arg)
  elif opt == '--version':
  version = arg

  //    rt = None
  while rt not in ['weekly', 'biweekly', 'monthly', 'quarterly', 'annually']:
  if rt:
  rt = raw_input('Sorry that was not an option, please respond with weekly, monthly, quarterly, or annually: ').lower()
  else:
  rt = raw_input('Do you make your payments weekly, biweekly, monthly, quarterly, or annually? ').lower()
  */



  std::cout<<"-------why is this so jacked up compared to the python code??";  
  printf("Using %.2f %% interest rate for %d months on $ %.2f loan with payments due XXXX and additional XXX payments of $ %.2f\n", r,t,la,al.get_overpaymenttoprincipal());
  std::cout<<"make a class that compares two objects(loans),computes total  interest of loan,total cost of loan,computes amount saved by paying off early, is there no closed form formula to calculate how much a loan costs you?";

check vs one of the online calcs. am I rounding to currency at the approp places?
  //the super class would just have two AmortizedLoan objects as members and then the super class would handle the comparison


  //  DualAmortizationTable(payment,r,la,rt,ep,t);
  //    AmortizationTable2(payment,r,la,rt,0)
  //    AmortizationTable2(payment,r,la,rt,ep)


}


//Create a function to calculate how much extra per month you would need to pay to pay off loan in X months instead of on normal schedule.
//This is just the difference between the normal mortgage payment for X periods vs Y periods.
//E.g. To pay off 30 yr in 15 yrs pay the 15 yr mortgage payment for your 30 yr mortgage. 

//write a bash version of this and see how much slower/faster it runs.
//write a java version of this and see how much faster it runs.
//write a C++ version of this and see how much faster it runs.
//write a C version of this and see how much faster it runs.


/*
  void AmortizedLoan::PrintfDual(int i,float pi1,float pp1,float p1,float pi2,float pp2,float p2)
  {
  float  pi1mpi2=0;
  float p1mp2=0;
  float pp2mpp1=0; //the payment to principal will be greater on the scenario where add'l payments are made.
  if (pi1-pi2>0)
  {
  pi1mpi2=pi1-pi2;
  }
  if (p1-p2>0 && p2!=0)
  {
  p1mp2=p1-p2;
  }
  
  printff("%3d | %10.2f  %10.2f %10.2f | %10.2f %10.2f %10.2f | %10.2f %10.2f " % (i,pi1,pp1,p1,pi2,pp2,p2,pi1mpi2,p1mp2));
    
  }

  void DualAmortizationTable(float periodicpayment,float int_rate, float principal,int freq,float additionalperiodicpaymenttoprincipal,int num_pmnts)
  {
  /*    import locale
  locale.setlocale(locale.LC_ALL,'') * /
  float p1=principal;
  float p2=principal;
  int i=1;
  float totint1=0;
  float totint2=0;
  bool  flag=false; //flag to prevent rewriting of month when p2 was paid off
  printf("//pmnt IntPmnt1 PrinPmnt1 Prin1 IntPmnt2 PrinPmnt2 Prin2 DiffIntPmnt DiffPrin");
  while (i <=  num_pmnts)
  {
  pi1,pp1,p1=CalcAmortizationValues(periodicpayment,int_rate,p1,freq,0);
  pi2,pp2,p2=CalcAmortizationValues(periodicpayment,int_rate,p2,freq,additionalperiodicpaymenttoprincipal);
  totint1+=pi1;
  totint2+=pi2;
  PrintfDual(i,pi1,pp1,p1,pi2,pp2,p2)

  if (p2==0 && flag==false) //this might not work since we can't *really* test if a float is 0
  {
  monthstopayoffwithaddlpayments=i;
  flag=true;
  }
	  
  i++;
  }
  printf("Total interest paid wo add'l payments:%s, with add'l payments %s, a difference of %s" % (locale.currency(totint1,grouping=True),locale.currency(totint2,grouping=True),locale.currency(totint1-totint2,grouping=True)))
  printf("The additional payments cut off %d months of the loan." % (num_pmnts-monthstopayoffwithaddlpayments))
  }
*/
